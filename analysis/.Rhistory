m <- MCMCglmm(discountResponse.change ~ -1 + trait + condition,
random = ~ us(trait):participantID.f,
rcov = ~ us(trait):units,
prior = list(
R = list(fix=1, V=0.5 * (I + J), n = 4),
G = list(
G1 = list(V = diag(3), n = 4)
)),
burnin = 100,
nitt = 1000,
family = "categorical",
data = d,
verbose = T)
m <- MCMCglmm(discountResponse.change ~ -1 + trait + condition,
random = ~ us(trait):participantID.f,
rcov = ~ us(trait):units,
prior = list(
R = list(fix=1, V=0.5 * (I + J), n = 4),
G = list(
G1 = list(V = diag(2), n = 4)
)),
burnin = 100,
nitt = 1000,
family = "categorical",
data = d,
verbose = T)
dim(d)
length(unique(d$participantID.f))
m <- MCMCglmm(discountResponse.change ~ -1 + trait + condition,
random = ~ us(trait):participantID.f,
rcov = ~ us(trait):units,
prior = list(
R = list(fix=1, V=0.5 * (I + J), n = 4),
G = list(
G1 = list(V = diag(121), n = 121)
)),
burnin = 100,
nitt = 1000,
family = "categorical",
data = d,
verbose = T)
m <- MCMCglmm(discountResponse.change ~ -1 + trait + condition,
random = ~ us(trait):participantID.f,
rcov = ~ us(trait):units,
prior = list(
#R = list(fix=1, V=0.5 * (I + J), n = 4),
R=list(V=1, n=1, fix=1),
G = list(
G1 = list(V = diag(121), n = 121)
)),
burnin = 100,
nitt = 1000,
family = "categorical",
data = d,
verbose = T)
m <- MCMCglmm(discountResponse.change ~ -1 + trait + condition,
random = ~ us(trait):participantID.f,
rcov = ~ us(trait):units,
prior = list(
#R = list(fix=1, V=0.5 * (I + J), n = 4),
R=list(V=1, n=1, fix=1),
G = list(
G1 = list(V = diag(1), n = 1)
)),
burnin = 100,
nitt = 1000,
family = "categorical",
data = d,
verbose = T)
m <- MCMCglmm(discountResponse.change ~ -1 + trait + condition,
random = ~ us(trait):participantID.f,
rcov = ~ us(trait):units,
prior = list(
#R = list(fix=1, V=0.5 * (I + J), n = 4),
R=list(V=1, n=1, fix=1),
G = list(
G1 = list(V = diag(2), n = 1)
)),
burnin = 100,
nitt = 1000,
family = "categorical",
data = d,
verbose = T)
m <- MCMCglmm(discountResponse.change ~ condition,
random = ~ us(1):participantID.f,
prior = list(
#R = list(fix=1, V=0.5 * (I + J), n = 4),
R=list(V=1, n=1, fix=1),
G = list(
G1 = list(V = diag(2), n = 1)
)),
burnin = 100,
nitt = 1000,
family = "categorical",
data = d,
verbose = T)
m <- MCMCglmm(discountResponse.change ~ condition,
random = ~ us(1):participantID.f,
prior = list(
#R = list(fix=1, V=0.5 * (I + J), n = 4),
R=list(V=1, n=1, fix=1),
G = list(
G1 = list(V = diag(2), n = 1)
)),
burnin = 100,
nitt = 1000,
family = "ordinal",
data = d,
verbose = T)
m <- MCMCglmm(discountResponse.change ~ condition,
random = ~ us(1):participantID.f,
prior = list(
#R = list(fix=1, V=0.5 * (I + J), n = 4),
R=list(V=1, n=1, fix=1),
G = list(
G1 = list(V = diag(1), n = 1)
)),
burnin = 100,
nitt = 1000,
family = "ordinal",
data = d,
verbose = T)
m
summary(m)
plot(m)
prior = list(
# Priors for residuals: minimal
R=list(V=1, n=1, fix=1),
# Priors on
G = list(
# only intercept for participant, therefore V = 1
# n = 1 (minimal)
G1 = list(V = diag(1), n = 1),
#
G2 = list(V = diag(1), n = 1),
G3 = list(V = diag(1), n = 1),
))
m <- MCMCglmm(discountResponse.change ~ condition,
random = ~
us(1):participantID.f +
us(1):amount.s +
us(1):logDays.s,
prior = prior,
burnin = 100,
nitt = 1000,
family = "ordinal",
data = d,
verbose = T)
prior = list(
# Priors for residuals: minimal
R=list(V=1, n=1, fix=1),
# Priors on
G = list(
# only intercept for participant, therefore V = 1
# n = 1 (minimal)
G1 = list(V = diag(1), n = 1),
#
G2 = list(V = diag(1), n = 1),
G3 = list(V = diag(1), n = 1)
))
m <- MCMCglmm(discountResponse.change ~ condition,
random = ~
us(1):participantID.f +
us(1):amount.s +
us(1):logDays.s,
prior = prior,
burnin = 100,
nitt = 1000,
family = "ordinal",
data = d,
verbose = T)
summary(m)
table(d$discountResponse.changelang)
table(d$discountResponse.change)
plot(m)
prior = list(
# Priors for residuals: minimal
R = list(fix=1, V=0.5 * (I + J), n = 2),
# Priors on
G = list(
# only intercept for participant, therefore V = 1
# n = 1 (minimal)
G1 = list(V = diag(1), n = 1),
# Prior for amount
G2 = list(V = diag(1), n = 1),
# Prior for log Days
G3 = list(V = diag(1), n = 1)
))
m <- MCMCglmm(discountResponse.change ~ condition,
random = ~
us(1):participantID.f +
us(1):amount.s +
us(1):logDays.s,
prior = prior,
burnin = 100, # Number of iterations before sampling
nitt = 1000,  # Number of iterations to sample
thin = 10,    # Reduce number of samples
family = "ordinal",
data = d,
verbose = T)
summary(m)
plot(m)
length(unique(d$participantID.f))
# Run the model
m <- MCMCglmm(discountResponse.change ~ condition,
random = ~
us(1):participantID.f +
us(1):amount.s +
us(1):logDays.s,
prior = prior,
burnin = 1000, # Number of iterations before sampling
nitt = 10000,  # Number of iterations to sample
thin = 10,    # Reduce number of samples
family = "ordinal",
data = d,
verbose = T)
summary(m)
plot(m)
# Priors for residuals: minimal
R=list(V=1, n=1, fix=1),
# Priors on
G = list(
# only intercept for participant, therefore V = 1
# n = 1 (minimal)
G1 = list(V = diag(1), n = 1),
# Prior for amount
G2 = list(V = diag(1), n = 1),
# Prior for log Days
G3 = list(V = diag(1), n = 1)
))
# Run the model
m <- MCMCglmm(discountResponse.change ~ condition,
random = ~
us(1):participantID.f +
us(1):amount.s +
us(1):logDays.s,
prior = prior,
burnin = 1000, # Number of iterations before sampling
nitt = 10000,  # Number of iterations to sample
thin = 10,    # Reduce number of samples
family = "ordinal",
data = d,
verbose = T)
prior = list(
# Priors for residuals: minimal
R=list(V=1, n=1, fix=1),
# Priors on
G = list(
# only intercept for participant, therefore V = 1
# n = 1 (minimal)
G1 = list(V = diag(1), n = 1),
# Prior for amount
G2 = list(V = diag(1), n = 1),
# Prior for log Days
G3 = list(V = diag(1), n = 1)
))
# Run the model
m <- MCMCglmm(discountResponse.change ~ condition,
random = ~
us(1):participantID.f +
us(1):amount.s +
us(1):logDays.s,
prior = prior,
burnin = 1000, # Number of iterations before sampling
nitt = 10000,  # Number of iterations to sample
thin = 10,    # Reduce number of samples
family = "ordinal",
data = d,
verbose = T)
summary(m)
??model.sel
?model.sel
library(MuMIn)
model.sel()
getMCMCglmmText = function(sx){
p = sx$pMCMC
if(p < 0.001){
p = "< 0.001"
} else{
p = signif(p,3)
}
paste0(c(
"beta = ", signif(sx$post.mean,3),
"[",signif(sx$`l-95% CI`,3),",",
signif(sx$`u-95% CI`,3),"] ",
"p = ",p),
collapse="")
}
sx.all = as.data.frame(summary(m)$solutions)
apply(sx.all,2,signif,digits=3)
getMCMCglmmText(sx.all[1,])
sx.all
plot(m)
plot(m)
summary(m)
---
title: "Cognitive influences in language evolution: Dutch data"
output: pdf_document
---
# Introduction
This is the model code for Monaghan & Roberts, "Cognitive influences in language evolution: Psycholinguistic predictors of loan word borrowing".  It takes data from the WOLD database of borrowing for Dutch and tries to predict whether a word has been borrowed or not according to various psycholinguitic measures.
```{r echo=F,eval=F}
setwd("~/Documents/MPI/MonaghanAoA/Stats 2/analysis/")
```
# Load libraries
```{r warning=F, message=F}
library(mgcv)
library(sjPlot)
library(lattice)
library(ggplot2)
library(gplots)
library(dplyr)
library(party)
library(lmtest)
library(gridExtra)
library(itsadug)
library(car)
library(caret)
library(scales)
library(binom)
logit2per = function(X){
return(exp(X)/(1+exp(X)))
}
rescaleGam = function(px, n, xvar, xlab=""){
y = logit2per(px[[n]]$fit)
x = px[[n]]$x *attr(xvar,"scaled:scale") + attr(xvar,"scaled:center")
se.upper = logit2per(px[[n]]$fit+px[[n]]$se)
se.lower = logit2per(px[[n]]$fit-px[[n]]$se)
dx = data.frame(x=x,y=y,ci.upper=se.upper,ci.lower=se.lower)
plen = ggplot(dx, aes(x=x,y=y))+
geom_ribbon(aes(ymin=ci.lower,ymax=ci.upper), alpha=0.3)+
geom_line(size=1) +
xlab(xlab)+
ylab("Probability of borrowing")+
coord_cartesian(ylim = c(0,1))
return(plen)
}
```
# Load data
The Dutch data is processed very similarly to the English data.  The full process can be found in the `processing` folder, but here we just load the final prepared data frame:
```{r}
load("../data/loanwords_Dutch.Rdat")
ls()
table(dutch$cat)
---
title: "Cognitive influences in language evolution: Rates of change"
output: pdf_document
---
```{r echo=F,eval=F}
setwd("~/Documents/MPI/MonaghanAoA/Stats 2/analysis/")
```
```{r echo=F}
getMEText = function(r,ef, wald=NULL, showWald=F){
AIC = r[2,]$AIC
loglikDiff = signif(diff(r$logLik),2)
chi = round(r$Chisq[2],2)
df = r$`Chi Df`[2]
p = signif(r$`Pr(>Chisq)`[2],2)
wald.text = ""
if(!is.null(wald)){
est = signif(wald[1],2)
stder = signif(wald[2],2)
t = signif(wald[3],2)
wptext = ""
wald.text =  paste("beta = ",est,",")
if(showWald){
if(!is.na(wald[4])){
wptext = paste(", Wald p =",signif(wald[4],2))
}
wald.text = paste("beta = ",est,", std.err = ",stder, ", Wald t = ",t,wptext,';')
}
}
begin = 'There was no significant'
if(p <0.09){
begin = "There was a marginal"
}
if(p < 0.05){
begin = 'There was a significant'
}
return(paste(begin,ef,"(",wald.text,"log likelihood difference =",
loglikDiff,", df = ",df,", Chi Squared =", chi,", p = ",p,")."))
}
```
# Introduction
We test whether rates of lexical replacement can be predicted by age of acuisition.  The key variables in the dataset `pagel/loanword9.csv` are:
-  word: orthographic form
-  borrowing: whether the word is borrowed into English, according to WOLD
-  phonology: phonological form, according to CELEX
-  phonlength: number of phonological segments
-  AoA: age of acuqisition, according to Kuperman et al. (2012)
-  subtlexzipf: frequency from SUBTLEX
-  pagel_rate:  rate of lexical replacement according to Pagel, Atkinson & Meade (2007)
-  cat: part of speech of the word
Pagel, Atkinson & Meade find that lexical replacement rates are higher for less frequent words, though the baseline rate differs by part of speech.  We use mixed effects modelling to investigate the effects of length, age of acquisition and concreteness, with random intercepts for part of speech.
# Load libraries
```{r message=FALSE, warning=F}
library(lme4)
library(sjPlot)
library(ggplot2)
library(gplots)
library(gridExtra)
library(mgcv)
```
# Load data
Scale and center all variables:
```{r}
d = read.csv("../data/pagel/loanword9.csv", stringsAsFactors = F)
d$pagel_rate = as.numeric(d$pagel_rate)
d$AoA = as.numeric(d$AoA)
d$subtlexzipf = as.numeric(d$subtlexzipf)
d$phonlength = as.numeric(d$phonlength)
d$conc = as.numeric(d$conc)
# group borrowing confidence
d$borrowing[d$borrowing==2] = 1
d$borrowing[d$borrowing==3] = NA
d$borrowing[d$borrowing==4] = 5
d$borrowing[d$borrowing==7] = NA
# complete cases only
d = d[complete.cases(d[,c("borrowing",'AoA','phonlength','conc','pagel_rate')]),]
```
Plot raw data:
```{r}
plotmeans(d$pagel_rate~d$borrowing)
ggplot(d, aes(AoA, as.numeric(pagel_rate))) +
geom_point() + stat_smooth(method="lm") +
ylab("Rate of replacement")
```
Scale variables for analysis:
```{r}
d$pagel_rate = scale(d$pagel_rate)
d$AoA.scale = scale(d$AoA)
d$subtlexzipf.scale = scale(d$subtlexzipf)
d$phonlength.scale = scale(d$phonlength)
d$conc.scale = scale(d$conc)
# most frequent category as intercept
d$borrowing = factor(d$borrowing,levels=c(5,1),labels = c("no","yes"))
d$borrowing.num = as.numeric(d$borrowing)-1
```
# Modelling
Null model:
```{r}
m0 = lmer(pagel_rate ~ 1 + (1|cat), data=d)
```
As expected, borrowed words have a higer rate of change:
```{r}
m1 = lmer(pagel_rate ~
borrowing +
(1|cat),
data = d)
anova(m0,m1)
```
The original model in Pagel et al. found relationships between rate of change, frequency and length:
```{r}
m2 = lmer(pagel_rate ~
borrowing +
subtlexzipf.scale +
(1 | cat),
data = d)
m3 = lmer(pagel_rate ~
borrowing +
subtlexzipf.scale +
phonlength.scale +
(1 | cat),
data = d)
anova(m1,m2,m3)
summary(m3)
```
Indeed, both length and freuqnecy are significant predictors of rate of change.
We can test whether there are non-linear effects for frequency and length:
```{r}
m3.freq2 = lmer(pagel_rate ~
borrowing +
subtlexzipf.scale +
I(subtlexzipf.scale^2) +
phonlength.scale +
(1 | cat),
data = d)
m3.len2 = lmer(pagel_rate ~
borrowing +
subtlexzipf.scale +
I(phonlength.scale^2) +
phonlength.scale +
(1 | cat),
data = d)
anova(m3, m3.freq2)
anova(m3, m3.len2)
```
There is no significant non-linear (quadratic) effect of frequency or length.
We can now add age of acquisition:
```{r}
m4 = lmer(pagel_rate ~
borrowing +
phonlength.scale +
subtlexzipf.scale +
AoA.scale +
(1 |cat),
data = d)
anova(m3,m4)
summary(m4)
```
Age of acquisition significantly improves the model and has an effect size similar to length (also, frequency has a much weaker effect).
Test the non-linear effect of age of acquisition:
```{r}
m4b = lmer(pagel_rate ~
borrowing +
phonlength.scale +
subtlexzipf.scale +
AoA.scale +
I(AoA.scale^2) +
(1 |cat),
data = d)
anova(m4,m4b)
